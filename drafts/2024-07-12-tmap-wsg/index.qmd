---
title: "Study area maps with tmap"
author: "al"
date: "2024-07-12"
date-modified: "`r format(Sys.time(), '%Y-%m-%d')`"
categories: [freshwater atlas, R]
image: "image.jpg"
params:
  repo_owner: "NewGraphEnvironment"
  repo_name: "new_graphiti"
  post_dir_name: "2024-07-12-tmap-wsg"
  update_pkgs: FALSE
  update_gis: FALSE
execute:
  warning: false
format: 
  html:
    code-fold: true
---

Visualize and quantify remotely sense land cover data.... Here is a first start.  We will use the European
Space Agency's WorldCover product which provides global land cover maps for the years 2020 and 2021 at 10 meter
resolution based on the combination of Sentinel-1 radar data and Sentinel-2 imagery.  We will use the 2021 dataset
for mapping an area of the Skeena watershed near Houston, British Columbia. 

<br>


This post was inspired - with much of the code copied - from a repository on GitHub from the wonderfully talented
[Milos Popovic](https://github.com/milos-agathon/esa-land-cover).  

<br>

First thing we will do is load our packages.  If you do not have the packages installed yet you can change the `update_pkgs` param in
the `yml` of this file to `TRUE`.  Using `pak` is great because it allows you to update your packages when you want to.

```{r ld-pkgs, message = FALSE}
pkgs_cran <- c(
  "tmap",
  "usethis",
  "here",
  "fs",
  "terra",
  "tidyverse",
  "rayshader",
  "sf",
  "classInt",
  "rgl",
  "tidyterra",
  "bcdata",
  "ggplot",
  "ggdark",
  "knitr",
  "DT",
  "htmlwidgets")

pkgs_gh <- c(
  "poissonconsulting/fwapgr",
  "NewGraphEnvironment/rfp"
 )

pkgs <- c(pkgs_cran, pkgs_gh)

if(params$update_pkgs){
  # install the pkgs
  lapply(pkgs,
         pak::pkg_install,
         ask = FALSE)
}

# load the pkgs
pkgs_ld <- c(pkgs_cran,
             basename(pkgs_gh))
invisible(
  lapply(pkgs_ld,
       require,
       character.only = TRUE)
)

source(here::here("scripts/staticimports.R"))
```

# Define our Area of Interest
We will grab our area of interest directly from the BC Data Catalougue. For this demo we will map the NECR watershed group.  We save a spatial file locally so we don't need to download each time we run this script.

```{r aoi-define, eval=params$update_gis}

schema_table <- "whse_basemapping.fwa_watershed_groups_poly"
schema_table_renamed <- stringi::stri_replace_all_fixed(schema_table, ".", "_")
path <- here::here('posts', params$post_dir_name, "data", paste0(
    schema_table_renamed,
    ".gpkg"))

# get the NECR watershed group
l_wsg <- rfp::rfp_bcd_get_data(
  bcdata_record_id = schema_table,
  col_filter = "watershed_group_code",
  col_filter_value = "NECR") |> 
  sf::st_transform(4326) |> 
  janitor::clean_names() 

stringi::stri_replace_all_fixed(schema_table, ".", "_")

  
l_wsg |>
  sf::st_write(path, delete_dsn = TRUE)

```


```{r aoi-get-local}
#read back in the aoi from file
aoi <- sf::st_read(path, quiet = TRUE)

```



```{r dl-layers, cache = TRUE}
# grab all the railways
l_rail <- rfp::rfp_bcd_get_data(
    bcdata_record_id = "whse_basemapping.gba_railway_tracks_sp"
) |> 
  sf::st_transform(4326) 

# streams in the bulkley and then filter to just keep the big ones
l_streams <- rfp::rfp_bcd_get_data(
  bcdata_record_id = "whse_basemapping.fwa_stream_networks_sp",
  col_filter = "watershed_group_code",
  col_filter_value = "NECR",
  # grab a smaller object by including less columns
  col_extract = c("linear_feature_id", "stream_order", "gnis_name", "downstream_route_measure", "blue_line_key", "length_metre")
) |> 
  sf::st_transform(4326) |> 
  dplyr::filter(stream_order > 4)

```

Now we trim up those layers. We have some functions to validate and repair geometries and then we clip them to our area of interest.

```{r clip-layers}
layers_to_trim <- tibble::lst(l_rail, l_streams)

# Function to validate and repair geometries
validate_geometries <- function(layer) {
  layer <- sf::st_make_valid(layer)
  layer <- layer[sf::st_is_valid(layer), ]
  return(layer)
}

# Apply validation to the AOI and layers
aoi <- validate_geometries(aoi)
layers_to_trim <- purrr::map(layers_to_trim, validate_geometries)

# clip them  with purrr and sf
layers_trimmed <- purrr::map(
  layers_to_trim,
  ~ sf::st_intersection(.x, aoi)
) 
```

<br>

# Understand `tmap`

Now let's get a quick understanding of `tmap`.  Who are the providers of raster tile layers?

```{r}
dat <- tmap::providers |> 
  tibble::enframe(name = NULL) 
 
dat |> 
  knitr::kable()

```


```{r}
qtm(l_wsg)
```

<br>

# Provincial Boundary
The `bcmaps::bc_bound` function gives us a hint on how to grab a low resolution spatial file representing the provincial boundaries.  
```{r}
# r <- bcdc_get_record("b9bd93e1-0226-4351-b943-05c6f80bd5da")
l_bc <- rfp::rfp_bcd_get_data(
  bcdata_record_id = "whse_basemapping.dbm_bc_7h_mil_political_poly",
  col_filter = "english_name",
  col_filter_value = "British Columbia"
) |> 
  sf::st_transform(4326) 

```

```{r}
plot(st_geometry(l_bc))

```

Now we will use tmap and plot our watershed on top of the provincial boundary.

```{r}

```

